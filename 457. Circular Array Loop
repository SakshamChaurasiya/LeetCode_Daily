//Brute force
class Solution {

    public int calNextIdx(int[] nums, int curr) {
        int next = curr;

        int seq = nums[curr];

        if (seq > 0) {
            next = (next + seq) % nums.length;
        } else {
           //mod with negatives
           int mod = seq% nums.length;
           int forward = nums.length+mod;
           next = (curr+forward) %nums.length;
        }
        return next;

    }

    public boolean circularArrayLoop(int[] nums) {
        //check for all the indexes
        for (int i = 0; i < nums.length; i++) {
            //set -> indexes we have already visited
            //flag -> isPos = nums[i]>0

            Set<Integer> set = new HashSet<>();

            set.add(i);

            boolean isPos = nums[i] > 0;

            int curr = i;
            //cycle detection
            while (true) {
                int next = calNextIdx(nums, curr);
                if (isPos) {
                    if (nums[next] < 0) {
                        break;
                    } else {
                        if (set.contains(next)) {
                            //cycle exist
                            //k>1
                            if (curr != next) {
                                return true;
                            } else {
                                break;
                            }
                        }
                        set.add(next);
                    }
                } else {
                    if (nums[next] > 0) {
                        break;
                    } else {
                        if (set.contains(next)) {
                            //cycle exist
                            //k>1
                            if (curr != next) {
                                return true;
                            } else {
                                break;
                            }
                        }
                        set.add(next);
                    }
                }

                curr = next;
            }
        }

        return false;
    }
}

//Approach 2 not iterating whole array
class Solution {

    public int calNextIdx(int[] nums, int curr) {
        int next = curr;

        int seq = nums[curr];

        if (seq > 0) {
            next = (next + seq) % nums.length;
        } else {
           //mod with negatives
           int mod = seq% nums.length;
           int forward = nums.length+mod;
           next = (curr+forward) %nums.length;
        }
        return next;

    }

    public boolean circularArrayLoop(int[] nums) {
        //check for all the indexes
        for (int i = 0; i < nums.length; i++) {
            //set -> indexes we have already visited
            //flag -> isPos = nums[i]>0

            if(nums[i]==0){
                continue;
            }

            Set<Integer> set = new HashSet<>();

            set.add(i);

            boolean isPos = nums[i] > 0;

            int curr = i;
            //cycle detection
            while (true) {
                int next = calNextIdx(nums, curr);
                if (isPos) {
                    if (nums[next] < 0) {
                        break;
                    } else {
                        if (set.contains(next)) {
                            //cycle exist
                            //k>1
                            if (curr != next) {
                                return true;
                            } else {
                                break;
                            }
                        }
                        set.add(next);
                    }
                } else {
                    if (nums[next] > 0) {
                        break;
                    } else {
                        if (set.contains(next)) {
                            //cycle exist
                            //k>1
                            if (curr != next) {
                                return true;
                            } else {
                                break;
                            }
                        }
                        set.add(next);
                    }
                }

                curr = next;
            }
            curr = i;
            if(isPos){
                while(nums[curr]>0){
                    int next = calNextIdx(nums,curr);

                    nums[curr]=0;
                    curr=next;
                }
            }else{
while(nums[curr]<0){
                    int next = calNextIdx(nums,curr);

                    nums[curr]=0;
                    curr=next;
                }
            }
        }

        return false;
    }
}

//fast slow pointer approach
class Solution {

    public int calNextIdx(int[] nums, int curr) {
        int next = curr;

        int seq = nums[curr];

        if (seq > 0) {
            next = (next + seq) % nums.length;
        } else {
            //mod with negatives
            int mod = seq % nums.length;
            int forward = nums.length + mod;
            next = (curr + forward) % nums.length;
        }
        return next;

    }

    public boolean circularArrayLoop(int[] nums) {
        //check for all the indexes
        for (int i = 0; i < nums.length; i++) {
            //set -> indexes we have already visited
            //flag -> isPos = nums[i]>0

            if (nums[i] == 0) {
                continue;
            }

            boolean isPos = nums[i] > 0;

            int slow = i;
            int fast = i;
            //cycle detection
            do {
                slow = calNextIdx(nums, slow);
                //all positives or all negatives
                //k>1

                fast = calNextIdx(nums, fast);

                if (isPos) {
                   if(nums[fast]<0){
                     break;
                   }
                }else{
                    if(nums[fast]>0){
                     break;
                   }
                }

                fast = calNextIdx(nums, fast);
                 if (isPos) {
                   if(nums[fast]<0){
                     break;
                   }
                }else{
                    if(nums[fast]>0){
                     break;
                   }
                }

                if (slow == fast) {
                    //cycle
                    //k>1
                    if(slow!=calNextIdx(nums,slow)){
                        return true;
                    }
                    break;
                }
            } while (slow != fast);

            int curr = i;
            if (isPos) {
                while (nums[curr] > 0) {
                    int next = calNextIdx(nums, curr);

                    nums[curr] = 0;
                    curr = next;
                }
            } else {
                while (nums[curr] < 0) {
                    int next = calNextIdx(nums, curr);

                    nums[curr] = 0;
                    curr = next;
                }
            }
        }

        return false;
    }
}
